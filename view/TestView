import SwiftUI

struct TypingAnimationWrapper: View {
    let textToType: String
    let maxHeight: CGFloat
    @State private var lines: [String] = []
    @State private var currentLine: String = ""
    @State private var currentIndex: Int = 0
    @State private var isTyping: Bool = true
    private let main: DispatchQueue
    private let typingDelay: Double = 0.2
    private let retractDelay: Double = 0.2
    private let pauseDelay: Double = 0.8
    
    init(textToType: String, maxHeight: CGFloat = 200) {
        self.textToType = textToType
        self.maxHeight = maxHeight
        self.main = DispatchQueue.main
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 4) {
            ScrollView(.vertical, showsIndicators: false) {
                VStack(alignment: .leading, spacing: 4) {
                    ForEach(lines.indices, id: \.self) { index in
                        Text(lines[index])
                            .font(.title)
                    }
                    Text(currentLine)
                        .font(.title)
                }
                .frame(maxWidth: .infinity, alignment: .leading)
            }
            .frame(maxHeight: maxHeight)
            .clipped() // This will hide any content that goes beyond the boundaries
        }
        .padding()
        .onAppear {
            animateText()
        }
    }
    
    func animateText() {
        isTyping = true
        currentLine = ""
        
        for index in 0..<textToType.count {
            main.asyncAfter(deadline: .now() + Double(index) * typingDelay) {
                if index < textToType.count {
                    let character = textToType[textToType.index(textToType.startIndex, offsetBy: index)]
                    currentLine.append(character)
                    UIImpactFeedbackGenerator(style: .light).impactOccurred()
                    
                    // Check if we need to start a new line
                    if character == "\n" {
                        lines.append(currentLine.trimmingCharacters(in: .newlines))
                        currentLine = ""
                    }
                }
                
                if index == textToType.count - 1 {
                    // Add the last line if it's not empty
                    if !currentLine.isEmpty {
                        lines.append(currentLine)
                        currentLine = ""
                    }
                    
                    main.asyncAfter(deadline: .now() + pauseDelay) {
                        retractText()
                    }
                }
            }
        }
    }
    
    func retractText() {
        isTyping = false
        
        if lines.isEmpty {
            // Nothing to retract, restart typing
            main.asyncAfter(deadline: .now() + pauseDelay) {
                animateText()
            }
            return
        }
        
        // Get the last line
        var lastLine = lines.removeLast()
        
        // Retract the last line character by character
        for index in 0..<lastLine.count {
            main.asyncAfter(deadline: .now() + Double(index) * retractDelay) {
                if !lastLine.isEmpty {
                    lastLine.removeLast()
                    currentLine = lastLine
                    UIImpactFeedbackGenerator(style: .light).impactOccurred()
                }
                
                if index == lastLine.count - 1 || lastLine.isEmpty {
                    main.asyncAfter(deadline: .now() + pauseDelay) {
                        // If all lines are empty, restart typing
                        if lines.isEmpty && currentLine.isEmpty {
                            animateText()
                        } else {
                            retractText()
                        }
                    }
                }
            }
        }
    }
}

// Extension to make it easier to use the wrapper
extension String {
    subscript(offset: Int) -> Character {
        self[index(startIndex, offsetBy: offset)]
    }
}

// Example usage:
struct ContentView: View {
    let textToType = "Hello, World!\nThis is a typing animation.\nWith multiple lines of text.\nIt will continuously type and retract text while respecting the height limit.\nText that exceeds the limit will be pushed upward and hidden."
    
    var body: some View {
        TypingAnimationWrapper(textToType: textToType, maxHeight: 150)
            .padding()
    }
}
