import SwiftUI

struct MultilineSlidingAnimationView: View {
    let textToType: String
    let displayWidth: Int
    let numberOfLines: Int = 3
    
    @State private var animatedLines: [String]
    @State private var isPaused: Bool = false
    @State private var currentPosition: Int = 0
    
    private let main: DispatchQueue
    
    init(textToType: String, displayWidth: Int) {
        self.textToType = textToType
        self.displayWidth = max(displayWidth, 1)
        
        // Initialize with empty lines
        self._animatedLines = State(initialValue: Array(repeating: String(repeating: " ", count: displayWidth), count: 3))
        self.main = DispatchQueue.main
    }
    
    var body: some View {
        VStack(alignment: .leading, spacing: 2) {
            // Display the three lines
            ForEach(0..<3, id: \.self) { index in
                Text(animatedLines[index])
                    .font(.system(size: 18, design: .monospaced))
                    .padding(4)
                    .frame(minWidth: 0, maxWidth: .infinity, alignment: .leading)
                    .background(Color.gray.opacity(0.1))
                    .cornerRadius(4)
            }
            
            HStack(spacing: 20) {
                Button(action: {
                    togglePause()
                }) {
                    Text(isPaused ? "Continue" : "Pause")
                        .foregroundColor(.white)
                        .padding(.horizontal, 20)
                        .padding(.vertical, 10)
                        .background(isPaused ? Color.green : Color.red)
                        .cornerRadius(8)
                }
                
                Button(action: {
                    resetAndRestart()
                }) {
                    Text("Reset")
                        .foregroundColor(.white)
                        .padding(.horizontal, 20)
                        .padding(.vertical, 10)
                        .background(Color.blue)
                        .cornerRadius(8)
                }
            }
            .padding(.top, 20)
        }
        .padding()
        .onAppear {
            animateText()
        }
    }
    
    func togglePause() {
        isPaused.toggle()
        
        if !isPaused {
            continueAnimation()
        }
    }
    
    func animateText() {
        currentPosition = 0
        continueAnimation()
    }
    
    func continueAnimation() {
        let totalLength = textToType.count
        let totalCapacity = displayWidth * numberOfLines
        
        func scheduleNextCharacter() {
            if currentPosition < totalLength && !isPaused {
                let character = textToType[textToType.index(textToType.startIndex, offsetBy: currentPosition)]
                
                main.asyncAfter(deadline: .now() + 0.1) {
                    if isPaused {
                        return
                    }
                    
                    // Calculate which line and position this character belongs to
                    let overallPosition = currentPosition % totalCapacity
                    let lineIndex = overallPosition / displayWidth
                    let positionInLine = overallPosition % displayWidth
                    
                    // Update the lines
                    var newLines = animatedLines
                    
                    if positionInLine == 0 {
                        // Need to shift lines upward when starting a new line
                        if lineIndex == 0 {
                            // All lines need to shift up
                            newLines[0] = newLines[1]
                            newLines[1] = newLines[2]
                            newLines[2] = String(repeating: " ", count: displayWidth)
                        }
                    }
                    
                    // Determine which line to modify
                    let targetLineIndex = min(lineIndex, numberOfLines - 1)
                    
                    // Modify the corresponding line
                    if positionInLine == 0 {
                        // Start a new character at the beginning of the line
                        var newLine = newLines[targetLineIndex]
                        if newLine.count > 0 {
                            newLine.removeFirst()
                        }
                        newLine.append(character)
                        newLines[targetLineIndex] = newLine
                    } else {
                        // Replace the character at the specific position
                        var newLine = newLines[targetLineIndex]
                        let index = newLine.index(newLine.startIndex, offsetBy: positionInLine)
                        if positionInLine < newLine.count {
                            newLine.remove(at: index)
                            newLine.insert(character, at: index)
                        } else if positionInLine == newLine.count {
                            newLine.append(character)
                        }
                        newLines[targetLineIndex] = newLine
                    }
                    
                    animatedLines = newLines
                    UIImpactFeedbackGenerator(style: .light).impactOccurred()
                    
                    currentPosition += 1
                    scheduleNextCharacter()
                }
            } else if !isPaused {
                // Finished typing all characters, restart after a pause
                main.asyncAfter(deadline: .now() + 2.0) {
                    if !isPaused {
                        resetAndRestart()
                    }
                }
            }
        }
        
        scheduleNextCharacter()
    }
    
    func resetAndRestart() {
        currentPosition = 0
        animatedLines = Array(repeating: String(repeating: " ", count: displayWidth), count: numberOfLines)
        
        if !isPaused {
            main.asyncAfter(deadline: .now() + 0.8) {
                if !isPaused {
                    animateText()
                }
            }
        }
    }
}

// Example usage
struct ContentView: View {
    var body: some View {
        MultilineSlidingAnimationView(
            textToType: "Welcome to my SwiftUI multi-line typing animation! This text will smoothly flow across three lines, creating a continuous stream of characters that demonstrates how to handle text overflow in a visually appealing way.",
            displayWidth: 30
        )
    }
}
