//
//  Parser.swift
//  ClipCC
//
//  Created by Karl Pfister on 3/12/18.
//  Copyright Â© 2018 Karl Pfister. All rights reserved.
//

import Foundation

class Parser {
    
    static let sharedInstance = Parser()
    
    
    // Our array of data points to display
    var transactions = [TransactionDetail]()
    
    func parseTransactions(tlvString: String, startIndex: Int = 0 ,startingLength: Int = 0) {
        // Tags can be either two or four character in legnth. theFirstTag is checking to see if the first two characters in the string can be read as a valid Tag
        let firstTag = tlvString.rangeOf(r: Range(startIndex...(startIndex + 1)))
        
        // If the first two characters can not make a tag - then the first four might be able too
        let secondTag = tlvString.rangeOf(r: Range(startIndex...(startIndex + 3)))
        
        /// Get tag
        let tagName = Tag.getTagName(tag: firstTag) ?? Tag.getTagName(tag: secondTag)
        let actualTag = Tag.getTagName(tag: firstTag) != nil ? firstTag : secondTag
        
        if tagName != nil {
            
            /// Get length
            let lengthStart = actualTag.count + startingLength
            // The legnth start takes in account the amount of characters in the tag along with where the last value ended
            let lengthEnd = (actualTag.count + 1) + startingLength
            // The legnth end takes in account the amount of characters in the tag along with where the last value ended while also disreguarding the first character in the length
            let hexLength = tlvString.rangeOf(r: Range(lengthStart...lengthEnd))
            // The hex value of the Length
            let length = Converter.hexToInt(hex: hexLength)
            // Converted hex to Int for use in the following equations
            /// Get value
            let value = tlvString.rangeOf(r: Range((lengthStart)...(length * 2) + lengthEnd))
            // Length is doubled as there are two bytes in each character
            let stringValue = Converter.hexToString(hex: value)
            // Convert the hex value into a String if possible
            let intValue = Converter.hexToInt(hex: value)
            // Convert the hex value into a Int if possible
            if intValue == 0 && stringValue == nil {
                // If the int value is 0 and the string value is nil - we want the value
                let td = TransactionDetail(tag: tagName!, tagDetail:actualTag, value: value)
                transactions.append(td)
            } else if intValue == 0 && stringValue != nil {
                // If the Int value can be converted into a 0 and the stringValue can be created - we want the string
                let td = TransactionDetail(tag: tagName!, tagDetail:actualTag, value: stringValue!)
                transactions.append(td)
            } else {
                // All that should be left is the IntValue case. Lets format the string to be more readable for what we expect
                let numberString = String(intValue, radix: 16)
                let formattedNumberString = numberString.dropFirst(1)
                
                let td = TransactionDetail(tag: tagName!, tagDetail:actualTag, value:formattedNumberString.uppercased())
                self.transactions.append(td)
            }
            //MARK: - Improvement I need to find a way to handle the excessdata.
            
            /// Manage recursion
            // Total count for this transaction, and where the next transaction starts
            let endOfTransaction = (length * 2 + (lengthEnd + 1))
            if endOfTransaction != tlvString.count {
                //
                parseTransactions(tlvString: tlvString, startIndex: endOfTransaction, startingLength: endOfTransaction)
                
            }
        }
    }
}

let mockQR ="85054350563031615f4f07a0000007300006500e46696e616e6369657261204543499f250290685a0a6008339300000499068f5f2d0665737074656e57136008339300000499068d27036010000000000fc501869f193131313131315f24032703315f340100636f5f2a0207049f02060000000010009f360200019f260891560d9a2cd86888820218009f102001150000000000000000000000000000000000000000000000000000000000009f3704773fcb7a950500000000009a032403229c01029f1a0207049f34032400029f0306000000000000"

extension String {
    
    func rangeOf(r: Range<Int>) -> String {
        let start = index(startIndex, offsetBy: r.lowerBound)
        let end = index(startIndex, offsetBy: r.upperBound)
        return String(self[Range(start ..< end)])
    }
}

class EMVDecoder {
    func decode(_ inputTLV: String) -> [String: Any] {
        var result: [String: Any] = [:]
        if let records = TKBERTLVRecord.sequenceOfRecords(from: hexStringToData(inputTLV)) {
            for record in records {
                let hexTag = String(record.tag, radix: 16).uppercased()
                let value = decodeValue(record.value, tag: record.tag)
                result["0x\(hexTag)"] = value
            }
        }
        return result
    }

    private func decodeValue(_ data: Data, tag: UInt64) -> Any {
        // Check if the tag is constructed (first bit of first byte is set to 1)
        let isConstructed = (tag & 0x20) != 0
        
        if isConstructed, let nestedRecords = TKBERTLVRecord.sequenceOfRecords(from: data) {
            // Recursively decode constructed data
            var nestedResult: [String: Any] = [:]
            for nestedRecord in nestedRecords {
                let nestedTag = String(nestedRecord.tag, radix: 16).uppercased()
                nestedResult["0x\(nestedTag)"] = decodeValue(nestedRecord.value, tag: nestedRecord.tag)
            }
            return nestedResult
        } else {
            // If not constructed, return the hex string value
            return hexEncodedString(from: data)
        }
    }

    private func hexEncodedString(from data: Data) -> String {
        return data.map { String(format: "%02X", $0) }.joined()
    }

    private func hexStringToData(_ hexString: String) -> Data {
        let hexString = hexString.replacingOccurrences(of: " ", with: "")
        var data = Data(capacity: hexString.count / 2)
        
        var index = hexString.startIndex
        while index < hexString.endIndex {
            let nextIndex = hexString.index(index, offsetBy: 2)
            let byteString = hexString[index..<nextIndex]
            if var byte = UInt8(byteString, radix: 16) {
                data.append(&byte, count: 1)
            }
            index = nextIndex
        }
        
        return data
    }
}

func checkMandatoryTags(in dictionary: [String: Any], mandatoryTags: [String]) -> [String: Bool] {
    var foundTags: Set<String> = []
    var missingTags: [String: Bool] = [:]

    // Helper function to recursively check tags
    func checkTags(_ dict: [String: Any]) {
        for (tag, value) in dict {
            // Check if the tag is in the list of mandatory tags
            if mandatoryTags.contains(tag) {
                foundTags.insert(tag)
            }
            
            // Recursively check nested dictionaries
            if let nestedDict = value as? [String: Any] {
                checkTags(nestedDict)
            }
        }
    }

    // Start checking tags in the main dictionary
    checkTags(dictionary)

    // Identify which mandatory tags are missing
    for tag in mandatoryTags {
        missingTags[tag] = foundTags.contains(tag)
    }

    return missingTags
}

// Example usage:
let mandatoryTags = ["0x5F20", "0x4F", "0x9F1E", "0x57", "0x9F4E", "0x42"]

let decodedEMV: [String: Any] = [
    "0x5F20": "54444320424C41434B20554E4C494D4954454420564953412020",
    "0x4F": "A0000000031010",
    "0xC2": [
        "0x9F1E": "31323334",
        "0x57": "1234567890123456D2212201123456F",
        "0x9F4E": [
            "0x42": "AABBCCDD"
        ]
    ]
]

let checkResult = checkMandatoryTags(in: decodedEMV, mandatoryTags: mandatoryTags)
print(checkResult)

func printDecodedTLV(_ dictionary: [String: Any], indent: String = "") {
    for (tag, value) in dictionary {
        if let nestedDict = value as? [String: Any] {
            // If the value is a nested dictionary, print the tag and recursively print its contents
            print("\(indent)\(tag): {")
            printDecodedTLV(nestedDict, indent: indent + "  ")
            print("\(indent)}")
        } else {
            // If the value is a simple string, print the tag and its value
            print("\(indent)\(tag): \(value)")
        }
    }
}
